package u2_3_Sorts;

import java.util.Arrays;
import java.util.Scanner;

/**
 * "5. . Сортировка вставками. Дана последовательность чисел a1, a2, ..., an. Требуется переставить числа в порядке возрастания. Делается это
 * следующим образом. Пусть a1, a2, ai - упорядоченная последовательность, т. е. a1 < a2 < ... < ai. Берется следующее
 * число и вставляется в последовательность так, чтобы новая последовательность была тоже возрастающей.
 * Процесс производится до тех пор, пока все элементы от i +1 до n не будут перебраны.
 * Примечание. Место помещения очередного элемента в отсортированную часть производить с помощью двоичного поиска.
 * Двоичный поиск оформить в виде отдельной функции."
 *
 * Длинна массива n считывается из потока ввода
 * Массив заполняется случайными целыми значениями в диапазоне [-99..99]
 * В данном решении не реализуются проверки на попадание в бесконечный цикл, а так же обработка исключений
 */

public class Task_5 {
    public static void main(String[] args) {
        // Считаем динну массива n из потока ввода
        Scanner in = new Scanner(System.in);
        System.out.print("Input the length of the array n: ");
        int n = in.nextInt();
        in.close();

        // Создадим массив a
        int[] a = new int[n];

        // Заполним массив случайными целыми значениями в диапазоне [-99..99]
        for (int i = 0; i < n; i++) {
            a[i] = ((int) (Math.random() * 199)) - 99;
        }

        // Выведем получившийся массив на экран
        System.out.println("Array:");
        System.out.println(Arrays.toString(a));

        // Создадим результирующий массив, который будем заполнять согласно условию
        int[] result = new int[n];

        // Если в массиве один элемент, выведем его на экран
        if (n == 1) {
            System.out.println("Result:");
            System.out.println(Arrays.toString(a));
        }
        // Создадим минимальную последовательнось, состоящую из двух элементов
        if (a[1] < a[0]) {
            result[0] = a[1];
            result[1] = a[0];
        }
        else {
            result[0] = a[0];
            result[1] = a[1];
        }
        /*
        На данном этапе мы имеем минимальную отсортированную последовательность из двух первых элементов массива
        Необходимо дальше идти по массиву a, и вставлять текущий элемент в последовательность согласно условию
        Очевидно, что начинать надо с 3ьего элемента массива, т.е. его индекс = 2
        Метод binarySearch - метод двоичного поиска индекса, куда необходимо вставить элемент
        Метод addToResult - метод добавления нужного элемента в результирующий массив по индексу, найденному binarySearch
         */
        // Объявим переменную для сохранения индекса, по которому надо вставить элемент
        int insert_to;
        // Заполним результирующий массив
        for (int i = 2; i < n; i++) {
            insert_to = binarySearch(result, a[i], i-1);
            addToResult(result, a[i], insert_to);
        }

        System.out.println("Result:");
        System.out.println(Arrays.toString(result));
    }

    /**
     * Метод двоичного поиска места помещения очередного элемента в отсортированную часть. Данный метод можно
     * использовать с произвольными массивами.
     * @param a - Входной массив
     * @param elem - Значение элемента, который необходимо вставить
     * @param last_index - Верхняя граница поиска в массиве
     * @return индекс, по которому элемент необходимо вставить в массив
     */
    public static int binarySearch(int[] a, int elem, int last_index) {
        if (elem <= a[0]) {
            return 0;
        }
        if (elem >= a[last_index]) {
            return last_index + 1;
        }
        int first = 0;
        int last = last_index;
        int cur_index = (first + last) / 2;
            while (first < last) {
                if (elem > a[cur_index]) {
                    if (elem <= a[cur_index + 1]) {
                        return cur_index + 1;
                    }
                    first = cur_index + 1;
                }
                else {
                    if (elem >= a[cur_index - 1]) {
                        return cur_index;
                    }
                    last = cur_index - 1;
                }
                cur_index = (first + last) / 2;
            }
        return cur_index + 1;
    }

    /**
     * Метод, реализующий вставку элемента в массив по определенному индексу. Производится сдвиг элементов вправо,
     * значение последнего элемента теряется. Поскольку в данной задаче мы заполняем новый массив, последние элементы
     * у неполного результирующего массива незначящие.
     * @param a - Входной массив
     * @param value - Значение, которое необходимо вставить
     * @param index - Индекс, по которому необходимо вставить value
     */
    public static void addToResult (int[] a, int value, int index) {
        for (int i = a.length-1; i > index ; i--) {
            a[i] = a[i-1];
        }
        a[index] = value;
    }
}
