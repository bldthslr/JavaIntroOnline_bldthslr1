package u2_3_Sorts;

import java.util.Scanner;

/**
 * "8.Даны дроби p1/q1, p2/q2, ..., pn/qn (pi, qi - натуральные).  Составить программу, которая приводит эти дроби к
 * общему знаменателю и упорядочивает их в порядке возрастания."
 *
 * Количество дробей n считывается из потока ввода
 * Далее каждая дробь считывается из потока ввода в виде двух простых чисел, введенных через пробел (например "3 5")
 * В качестве нахождения общего знаменателя будем находить наименьший общий знаменатель.
 * Для нахождения наименьшего общего знаменателя знаменатель каждой дроби раскладывается на простые множители,
 * а затем все уникальные простые множители перемножаются.
 * Для добавления простых множителей создадим отдельный метод addIfNotThereWithCount.
 * В данном решении не реализуются проверки на попадание в бесконечный цикл, а так же обработка исключений
 */

public class Task_8 {
    public static void main(String[] args) {
        // Считаем количество дробей n из потока ввода
        Scanner in = new Scanner(System.in);
        System.out.print("Input number of fractions n: ");
        int n = in.nextInt();
        // Объявим два массива для числителей и знаменателей
        int[] num = new int[n];
        int[] den = new int[n];
        // Заполним эти массивы из потока ввода
        for (int i = 0; i < n; i++) {
            System.out.println("Enter the numerator and denominator of the " + (i + 1) + "st fraction separated by a space:");
            num[i] = in.nextInt();
            den[i] = in.nextInt();
        }
        in.close();

         /*
            Для разложения числа на простые множители, для начала, поделить его на 2.
            Если число разделится на 2 без остатка, то 2 – это первый множитель.
            Далее полученный результат опять делим на 2, если число разделится на 2 без остатка,
            то второй множитель тоже 2. Если же при делении получается остаток, то пробуем делим на 3, 4, ... n,
            до тех пор число не разделится без остатка.
            Для добавления числа
         */
        // Обявим массив для хранения простых множетелей у делителей, а так же нужные для работы алгоритма переменные
        int[] mlt = new int[30];
        int denum, div, count;
        boolean isMullt;
        // Для каждого делителя найдем простые множители, и добавим их в массив, если их нет, с помощью addIfNotThere
        for (int i = 0; i < n; i++) {
            // Текущий делитель, который будем разбивать на множители
            denum = den[i];
            // Начинаем делить от двух, и заканчивая делителем (если число простое, то найдется один множитель - это число)
            for (div = 2; div <= denum; div++) {
                isMullt = false;
                count = 0;
                // Если делится без остатка, значит "условие" выполнено. Делим число в цикле
                while (denum % div == 0) {
                    denum /= div;
                    isMullt = true;
                    count++;
                }
                // Если условие сработало и был найден искомый множитель, попробуем добавить его в массив множдителей
                if (isMullt) {
                    addIfNotThereWithCount(mlt, div, count);
                }
            }
        }

        /*
        На данном этапе мы имеем массив mlt, содержащий все уникальные множители всех делителей
        с незначащими нулями в конце. Для того, чтобы найти наименьший общий знаменатель, просто перемножим все
        значащие элементы массива mlt
         */
        int lowDen = 1;
        for (int i = 0; i < mlt.length; i++) {
            if (mlt[i] != 0) {
                lowDen *= mlt[i];
            }
        }

        // Теперь все числители дробей можно привести к общему знаменателю
        for (int i = 0; i < n; i++) {
            num[i] *= lowDen / den[i];
        }

        // Отсортируем массив числителей:
        //Arrays.sort(num);
        Task_6.shellSort(num);

        // Выведем результат на экран
        for (int i = 0; i < n; i++) {
            System.out.println(num[i] + "/" + lowDen);
        }
    }


    /**
     * Добавляет элемент некоторое количество раз, если его нет в массиве. Если элемент есть в массиве, уменьшает
     * счетчик на 1. Индекс добавления - первый нулевой элемент.
     * @param a - входной массив
     * @param elem - элемент, который необходимо добавить
     * @param count - количество добавлений в массив
     */
    public static void addIfNotThereWithCount(int[] a, int elem, int count) {
        for (int i = 0; i < a.length; i++) {
            if (elem == a[i]) {
                count--;
            }
        }
         while (count > 0) {
             for (int i = 0; i < a.length; i++) {
                 if (a[i] == 0) {
                     a[i] = elem;
                     break;
                 }
             }
             count--;
        }
    }


}
